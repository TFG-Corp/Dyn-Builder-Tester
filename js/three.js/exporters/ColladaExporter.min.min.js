THREE.ColladaExporter=function(){};THREE.ColladaExporter.prototype={constructor:THREE.ColladaExporter,parse:function(e,r,a={}){a=Object.assign({version:"1.4.1",author:null,textureDirectory:""},a);if(a.textureDirectory!==""){a.textureDirectory=`${a.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/")}var t=a.version;if(t!=="1.4.1"&&t!=="1.5.0"){console.warn(`ColladaExporter : Version ${t} not supported for export. Only 1.4.1 and 1.5.0.`);return null}function i(e){var r=/^<\//;var a=/(\?>$)|(\/>$)/;var t=/<[^>]+>[^<]*<\/[^<]+>/;var i=(e,r)=>r>0?e+i(e,r-1):"";var n=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map(e=>{if(!t.test(e)&&!a.test(e)&&r.test(e)){n--}var o=`${i("  ",n)}${e}`;if(!t.test(e)&&!a.test(e)&&!r.test(e)){n++}return o}).join("\n")}function n(e){var r=atob(e);var a=new Uint8Array(r.length);for(var t=0,i=a.length;t<i;t++){a[t]=r.charCodeAt(t)}return a}var o,s;function u(e,r){o=o||document.createElement("canvas");s=s||o.getContext("2d");o.width=e.naturalWidth;o.height=e.naturalHeight;s.drawImage(e,0,0);var a=o.toDataURL(`image/${r}`,1).replace(/^data:image\/(png|jpg);base64,/,"");return n(a)}var l=["getX","getY","getZ","getW"];function c(e){if(e.isInterleavedBufferAttribute){var r=new e.array.constructor(e.count*e.itemSize);var a=e.itemSize;for(var t=0,i=e.count;t<i;t++){for(var n=0;n<a;n++){r[t*a+n]=e[l[n]](t)}}return r}else{return e.array}}function m(e,r,a){if(Array.isArray(e))return e.slice(r,r+a);else return new e.constructor(e.buffer,r*e.BYTES_PER_ELEMENT,a)}function f(e,r,a,t){var i=c(e);var n=`<source id="${r}">`+`<float_array id="${r}-array" count="${i.length}">`+i.join(" ")+"</float_array>"+"<technique_common>"+`<accessor source="#${r}-array" count="${Math.floor(i.length/e.itemSize)}" stride="${e.itemSize}">`+a.map(e=>`<param name="${e}" type="${t}" />`).join("")+"</accessor>"+"</technique_common>"+"</source>";return n}var p;function v(e){e.updateMatrix();p=p||new THREE.Matrix4;p.copy(e.matrix);p.transpose();return`<matrix>${p.toArray().join(" ")}</matrix>`}function d(e){var r=y.get(e);if(!r){var a=e;if(a instanceof THREE.Geometry){a=(new THREE.BufferGeometry).fromGeometry(a)}var t=`Mesh${w.length+1}`;var i=a.index?a.index.count*a.index.itemSize:a.attributes.position.count;var n=a.groups!=null&&a.groups.length!==0?a.groups:[{start:0,count:i,materialIndex:0}];var o=`<geometry id="${t}" name="${e.name}"><mesh>`;var s=`${t}-position`;var u=`${t}-vertices`;o+=f(a.attributes.position,s,["X","Y","Z"],"float");o+=`<vertices id="${u}"><input semantic="POSITION" source="#${s}" /></vertices>`;var l=`<input semantic="VERTEX" source="#${u}" offset="0" />`;if("normal"in a.attributes){var p=`${t}-normal`;o+=f(a.attributes.normal,p,["X","Y","Z"],"float");l+=`<input semantic="NORMAL" source="#${p}" offset="0" />`}if("uv"in a.attributes){var v=`${t}-texcoord`;o+=f(a.attributes.uv,v,["S","T"],"float");l+=`<input semantic="TEXCOORD" source="#${v}" offset="0" set="0" />`}if("color"in a.attributes){var d=`${t}-color`;o+=f(a.attributes.color,d,["X","Y","Z"],"uint8");l+=`<input semantic="COLOR" source="#${d}" offset="0" />`}var $=null;if(a.index){$=c(a.index)}else{$=new Array(i);for(var g=0,h=$.length;g<h;g++)$[g]=g}for(var g=0,h=n.length;g<h;g++){var _=n[g];var E=m($,_.start,_.count);var x=E.length/3;o+=`<triangles material="MESH_MATERIAL_${_.materialIndex}" count="${x}">`;o+=l;o+=`<p>${E.join(" ")}</p>`;o+="</triangles>"}o+=`</mesh></geometry>`;w.push(o);r={meshid:t,bufferGeometry:a};y.set(e,r)}return r}function $(e){var r=E.get(e);if(r==null){r=`image-${b.length+1}`;var i="png";var n=e.name||r;var o=`<image id="${r}" name="${n}">`;if(t==="1.5.0"){o+=`<init_from><ref>${a.textureDirectory}${n}.${i}</ref></init_from>`}else{o+=`<init_from>${a.textureDirectory}${n}.${i}</init_from>`}o+="</image>";b.push(o);E.set(e,r);x.push({directory:a.textureDirectory,name:n,ext:i,data:u(e.image,i),original:e})}return r}function g(e){var r=_.get(e);if(r==null){r=`Mat${M.length+1}`;var a="phong";if(e instanceof THREE.MeshLambertMaterial){a="lambert"}else if(e instanceof THREE.MeshBasicMaterial){a="constant";if(e.map!==null){console.warn("ColladaExporter: Texture maps not supported with MeshBasicMaterial.")}}var t=e.emissive?e.emissive:new THREE.Color(0,0,0);var i=e.color?e.color:new THREE.Color(0,0,0);var n=e.specular?e.specular:new THREE.Color(1,1,1);var o=e.shininess||0;var s=e.reflectivity||0;var u="";if(e.transparent===true){u+=`<transparent>`+(e.map?`<texture texture="diffuse-sampler"></texture>`:"<float>1</float>")+"</transparent>";if(e.opacity<1){u+=`<transparency><float>${e.opacity}</float></transparency>`}}var l=`<technique sid="common"><${a}>`+"<emission>"+(e.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${t.r} ${t.g} ${t.b} 1</color>`)+"</emission>"+(a!=="constant"?"<diffuse>"+(e.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${i.r} ${i.g} ${i.b} 1</color>`)+"</diffuse>":"")+(a==="phong"?`<specular><color sid="specular">${n.r} ${n.g} ${n.b} 1</color></specular>`+"<shininess>"+(e.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${o}</float>`)+"</shininess>":"")+`<reflective><color>${i.r} ${i.g} ${i.b} 1</color></reflective>`+`<reflectivity><float>${s}</float></reflectivity>`+u+`</${a}></technique>`;var c=`<effect id="${r}-effect">`+"<profile_COMMON>"+(e.map?'<newparam sid="diffuse-surface"><surface type="2D">'+`<init_from>${$(e.map)}</init_from>`+"</surface></newparam>"+'<newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>':"")+(e.specularMap?'<newparam sid="specular-surface"><surface type="2D">'+`<init_from>${$(e.specularMap)}</init_from>`+"</surface></newparam>"+'<newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>':"")+(e.emissiveMap?'<newparam sid="emissive-surface"><surface type="2D">'+`<init_from>${$(e.emissiveMap)}</init_from>`+"</surface></newparam>"+'<newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>':"")+l+(e.side===THREE.DoubleSide?`<extra><technique><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>`:"")+"</profile_COMMON>"+"</effect>";T.push(`<material id="${r}" name="${e.name}"><instance_effect url="#${r}-effect" /></material>`);M.push(c);_.set(e,r)}return r}function h(e){var r=`<node name="${e.name}">`;r+=v(e);if(e instanceof THREE.Mesh&&e.geometry!=null){var a=d(e.geometry);var t=a.meshid;var i=a.bufferGeometry;var n=null;var o=[];var s=e.material||new THREE.MeshBasicMaterial;var u=Array.isArray(s)?s:[s];if(i.groups.length>u.length){o=new Array(i.groups.length)}else{o=new Array(u.length)}n=o.fill().map((e,r)=>g(u[r%u.length]));r+=`<instance_geometry url="#${t}">`+(n!=null?"<bind_material><technique_common>"+n.map((e,r)=>`<instance_material symbol="MESH_MATERIAL_${r}" target="#${e}" >`+'<bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" />'+"</instance_material>").join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}e.children.forEach(e=>r+=h(e));r+="</node>";return r}var y=new WeakMap;var _=new WeakMap;var E=new WeakMap;var x=[];var b=[];var w=[];var M=[];var T=[];var D=h(e);var O=t==="1.4.1"?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/";var R='<?xml version="1.0" encoding="UTF-8" standalone="no" ?>'+`<COLLADA xmlns="${O}" version="${t}">`+"<asset>"+("<contributor>"+"<authoring_tool>THREE.js Collada Exporter</authoring_tool>"+(a.author!==null?`<author>${a.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified>`+"<up_axis>Y_UP</up_axis>")+"</asset>";R+=`<library_images>${b.join("")}</library_images>`;R+=`<library_effects>${M.join("")}</library_effects>`;R+=`<library_materials>${T.join("")}</library_materials>`;R+=`<library_geometries>${w.join("")}</library_geometries>`;R+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${D}</visual_scene></library_visual_scenes>`;R+='<scene><instance_visual_scene url="#Scene"/></scene>';R+="</COLLADA>";var A={data:i(R),textures:x};if(typeof r==="function"){requestAnimationFrame(()=>r(A))}return A}};
//# sourceMappingURL=ColladaExporter.min.min.js.map